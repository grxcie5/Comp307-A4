import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Utility {

    /**
     * Calculate the Euclidean distance between two VRP nodes
     * @param node1 the first VRP node
     * @param node2 the second VRP node
     * @return the Euclidean distance between node1 and node2
     */
    public static double calculateEuclideanDistance(VRPNode node1, VRPNode node2) {
        // TODO: Implement the function to calculate the Euclidean distance.
        double ed = Math.pow(node1.getX() - node2.getX(), 2) + Math.pow(node1.getY() - node2.getY(), 2);
        return Math.sqrt(ed);
    }

    /**
     * Calculate the total cost of a VRP solution under a VRP instance.
     * The total cost is the sum of all the Euclidean distance between adjacent nodes in the routes.
     * @param solution the VRP solution.
     * @param instance the VRP instance.
     * @return the total cost of the solution.
     */
    public static double calculateTotalCost(VRPSolution solution, VRPInstance instance) {
        // TODO: Implement the function to calculate the total cost of the solution.
//        Map<Integer, VRPNode> nodes = instance.getNodes();
//        double cost =0;
//        for(List<Integer> route : solution.getRoutes()){
//            //System.out.println(route.size());
//            for(int i=0; i < route.size(); i++) {
//                if (i + 1 < route.size()){
//                    cost += calculateEuclideanDistance(nodes.get(i), nodes.get(i + 1));
//                }
//            }
//        }
//        return cost;

        double totalCost = 0;
        Map<Integer, VRPNode> nodes = instance.getNodes();
        for(int i=0; i<solution.getRoutes().size(); i++){
            for(int j=0; j + 1< solution.getRoutes().get(i).size(); j++){
                Integer node1 = solution.getRoutes().get(i).get(j);
                Integer node2 = solution.getRoutes().get(i).get(j+1);
                totalCost += calculateEuclideanDistance(nodes.get(node1), nodes.get(node2));
            }
        }
       return totalCost;
    }

    /**
     * Generate a VRP solution for a VRP instance using the nearest neighbour heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the nearest neighbour heuristic.
     */
    public static VRPSolution nearestNeighbourHeuristic(VRPInstance instance) {
        // TODO: Implement the nearest neighbour heuristic.
        List<List<Integer>> routesSolution = new ArrayList<>();

        VRPNode depot = instance.getDepot();
        double capacity = instance.getCapacity();
        Map<Integer, VRPNode> nodes = instance.getNodes(); //key is id

        List<Integer> visited = new ArrayList<>();
        List<Integer> unvisited = new ArrayList<>();
        List<Integer> currentRoute = new ArrayList<>();
        //set unvisited for the while loop
        for(Integer id : nodes.keySet()){
            unvisited.add(id);
        }

        double routeDemand = 0;
        VRPNode currentNode = depot;
        //initialise solution starting from depot
        //append the nearest feasible node to the route - unvisited and won't exceed capacity
        //(if current demand + nn demand <= capacity)
        //if no feasible is found close the route (return to depot) and create new route from depot
        //repeat until all nodes are visited.
        while(!unvisited.isEmpty()){
            //find the closest to the current node
            Integer closestNode = -1;
            double distance = Double.MAX_VALUE;
            for(Map.Entry<Integer, VRPNode> n : nodes.entrySet()){
                if(!visited.contains(n.getKey())){ //make sure the node is not visited already
                    if((calculateEuclideanDistance(currentNode, n.getValue()) < distance) && isFeasible(capacity,routeDemand, n.getValue())){
                        distance = calculateEuclideanDistance(currentNode, n.getValue());
                        closestNode = n.getKey();
                    }
                }
            }

            if(closestNode != -1){ // a closest feasible node has been found
                //add to route and stuff
                currentRoute.add(closestNode); // add the nodes id to the route
                currentNode = nodes.get(closestNode); //set the current node
                visited.add(closestNode); //add the node to visited
                unvisited.remove(closestNode); //remove the node from unvisited
                routeDemand += nodes.get(closestNode).getDemand(); //add the nodes demand to the route
                if(unvisited.isEmpty()){ //the nodes have reached the end - this is the last node
                    currentRoute.add(depot.getID()); //go back to depot
                    List<Integer> copy = new ArrayList<>(currentRoute);
                    routesSolution.add(copy); //add the route to the solution
                }
            } else { //there is no node that will not go over capacity
                //end route and stuff
                currentRoute.add(depot.getID()); //go back to depot
                List<Integer> copy = new ArrayList<>(currentRoute);
                routesSolution.add(copy); //add the route to the solution
                currentRoute.clear();
                currentRoute.add(depot.getID()); //start from depot again
                currentNode = depot;
                routeDemand = 0;
            }
        }

        System.out.println("there are " + routesSolution.size() + " routes");
        VRPSolution solution = new VRPSolution(routesSolution);

        return solution;
    }

    public static boolean isFeasible(double capacity, double routeDemand, VRPNode node){
        if(node.getDemand() + routeDemand <= capacity){
            return true;
        }
        return false;
    }

    /**
     * Generate a VRP solution for a VRP instance using the savings heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the savings heuristic.
     */
    public static VRPSolution savingsHeuristic(VRPInstance instance) {
        // TODO: Implement the savings heuristic.
        Map<Integer, VRPNode> nodes = instance.getNodes();
        VRPNode depot = instance.getDepot();
        List<List<Integer>> solutionList = new ArrayList<>();
        List<List<Integer> > initialNodeRoutes = new ArrayList<>();
        List<Integer> currentRoute = new ArrayList<>();
        double routeDemand = 0;
        //step 1 - make routes of all nodes
        for(Map.Entry<Integer, VRPNode> n : nodes.entrySet()){
            List<Integer> nodeRoute = new ArrayList<>();
            //nodeRoute.add(1);
            nodeRoute.add(n.getKey());
            //nodeRoute.add(1);
            initialNodeRoutes.add(nodeRoute);
        }
        //step 2 - compute and store savings for each possible merge
        Map<List<Integer>, Double> mergedSavings = new HashMap<>();
        for(int i=0; i<initialNodeRoutes.size(); i++){
            for(int j=0; j<initialNodeRoutes.size(); j++){
                //if it's not itself
                if(!initialNodeRoutes.get(i).equals(initialNodeRoutes.get(j))){
                    //merge them and store the merge
                    List<Integer> merged = new ArrayList<>();
                    merged.addAll(initialNodeRoutes.get(j));
                    merged.addAll(initialNodeRoutes.get(i));
                    double savings = computeSavings(initialNodeRoutes.get(j), initialNodeRoutes.get(i), nodes, depot);
                    mergedSavings.put(merged, savings);
                }
            }

        }

        //step 3 - check all possible/feasible route merges
        //step - 4 choose the merge with the biggest savings
        //while loop here
        //for every list in the map check if the merge is feasible
        double savings = 0;
        for(Map.Entry<List<Integer>, Double> n : mergedSavings.entrySet()){

        }
        VRPSolution solution = new VRPSolution(solutionList);
        return solution;
    }

    private static double computeSavings(List<Integer> i, List<Integer> j, Map<Integer, VRPNode> nodes, VRPNode depot) {
        double disti = calculateEuclideanDistance(nodes.get(i.get(0)), depot);
        double distj = calculateEuclideanDistance(nodes.get(j.get(0)), depot);
        double distij = calculateEuclideanDistance(nodes.get(i.get(0)), nodes.get(j.get(0)));
        double savings = disti + distj - distij;
        return savings;
    }

}
